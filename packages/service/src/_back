import { Observable, Subject } from 'rxjs'
import { throttleTime } from 'rxjs/operators'

export type TableDataRowState<TableRow> = TableRow & { $selected: boolean }

export interface TableList<TableRow> {
  total: number
  list: TableRow[]

  [key: string]: any
}

export interface TableState<TableRow> {
  selectAll: boolean,
  selectCount: number,
  pageSelectCount: number,
  data: TableList<TableRow>
}

export interface TableRequestParams {
  page: number
  limit: number
  useMemory: boolean
}

/**
 * 表格内存分页控制类
 *
 * @description
 * 用于表格跨页选择、分布查看已选择的数据等功能，在实际使用时需继承 TableMemoryPagination 类，并实现其抽象方法。
 * 和其它正常数据请求不一样，使用 TableMemoryPagination 获取数据时，不能直接调用其 getListByServer 方法，而应该通过订阅
 * onStateChange 来观察数据变化，并根据返回的状态数据渲染表格及其它页面元素。同时，发送请求也应该通过 refresh 方法来触发。
 */
export abstract class TableMemoryPagination<RequestParams extends TableRequestParams, TableRow> {
  /**
   * 表格状态数据观察者对象。你应该始终从这里获取数据。
   */
  onStateChange: Observable<TableState<TableDataRowState<TableRow>>>

  private state: TableState<TableDataRowState<TableRow>> = {
    selectAll: false, // 是否全选
    selectCount: 0, // 全部选择计数
    pageSelectCount: 0, // 当页选择计数
    data: {
      total: 0,
      list: []
    }
  }

  private lastQueryParams: RequestParams // 上一次请求缓存 用于判断是否需要拷贝一份selectData
  private selectedData: TableDataRowState<TableRow>[] = [] // 选中数据
  private memoryData: TableDataRowState<TableRow>[] = [] // 展示选中数据的缓存
  private reflush = true // 是否刷新页面

  private totalCount = 0
  private stateChangeEvent = new Subject<TableState<TableDataRowState<TableRow>>>()

  protected constructor () {
    // eslint-disable-next-line no-magic-numbers
    this.onStateChange = this.stateChangeEvent.asObservable().pipe(throttleTime(10))
  }

  /**
   * 获取已选择的数据
   */
  getSelectedData () {
    return this.selectedData.map(i => i)
  }

  /**
   * 刷新数据，TableMemoryPagination 会根椐查询条件，把最新的数据通过 onStateChange 观察者通知订阅者
   * @param params 请求参数
   */
  refresh (params: RequestParams): void {
    this.getTableData(params).then(response => {
      this.state.data = response
      this.reflush = true
      this.state.pageSelectCount = 0
      this.stateChangeEvent.next({
        ...this.state
      })
    })
    this.lastQueryParams = {
      ...params
    }
  }

  /**
   * 合并选择数据，如果有第二个参数，则视为在当前已选择的数据中排除。（主要是适配 ElementUI 的逻辑）
   * @param items 最新选择的数据（内部会做去重操作）
   * @param currentRow 要排队的数据
   */
  mergeSelectedData (items: TableDataRowState<TableRow>[], currentRow?: TableDataRowState<TableRow>) {
    if (currentRow) { // 手动 - 单选
      const idx = this.selectedData.findIndex(el => this.isEqual(el, currentRow))
      const ele = this.state.data.list.find(el => this.isEqual(el, currentRow))
      if (idx !== -1) {
        ele.$selected = false
        this.state.pageSelectCount--
        this.selectedData.splice(idx, 1)
      } else {
        ele.$selected = true
        this.state.pageSelectCount++
        this.selectedData.push(ele)
      }
    } else { // 自动 - 只做当页全选 / 反选
      if (items.length === this.state.data.list.length) {
        this.state.data.list.forEach(row => {
          row.$selected = true
          const idx = this.selectedData.findIndex(el => this.isEqual(el, row))
          if (idx === -1) {
            this.selectedData.push(row)
          }
        })
        this.state.pageSelectCount = this.state.data.list.length
      } else if (items.length === 0 && !this.reflush) {
        this.state.data.list.forEach(row => {
          row.$selected = false
          const idx = this.selectedData.findIndex(el => this.isEqual(el, row))
          if (idx !== -1) {
            this.selectedData.splice(idx, 1)
          }
        })
        this.state.pageSelectCount = 0
      }
    }
    this.reflush = false
    this.stateChangeEvent.next({
      ...this.state,
      selectCount: this.selectedData.length,
    })
  }

  /**
   * 切换当前页全选状态
   */
  togglePageSelect (check?: boolean) {
    if (
      (typeof check !== 'undefined' && check) ||
      (this.state.pageSelectCount !== this.state.data.list.length)
    ) {
      this.reflush = true
      this.mergeSelectedData(this.state.data.list)
    } else {
      this.mergeSelectedData([])
    }
  }

  /**
   * 设置全选所有数据，这里的所有数据指服务端的所有数据，而不是指前段当前页
   */
  selectAll () {
    this.selectedData = []
    this.state.selectAll = true
    this.state.selectCount = this.totalCount

    this.stateChangeEvent.next({
      ...this.state,
      data: {
        ...this.state.data,
        list: this.state.data.list.map(i => {
          i.$selected = true
          return i
        })
      }
    })
  }

  /**
   * 设置取消全选所有数据，这里的所有数据指服务端的所有数据，而不是指前段当前页
   */
  cancelSelectAll () {
    this.selectedData = []
    this.state.selectAll = false
    this.state.selectCount = 0
    this.stateChangeEvent.next({
      ...this.state,
      data: {
        ...this.state.data,
        list: this.state.data.list.map(i => {
          i.$selected = false
          return i
        })
      }
    })
  }

  /**
   * 子类需要实现的从服务器获取数据的方法，TableMemoryPagination 会根据查询条件来调用此方法。你不应该主动调用此方法
   * @param params
   */
  abstract getListByServer (params: RequestParams): Promise<TableList<TableRow>>

  /**
   * 子类需要实现的数据对比方法，TableMemoryPagination 会在做去重操作的时候调用
   * @param left
   * @param right
   */
  abstract isEqual (left: TableRow, right: TableRow): boolean

  // 发请求
  private getTableData (params: RequestParams): Promise<TableList<TableDataRowState<TableRow>>> {
    if (params.useMemory && !this.state.selectAll) { // 全选则走http请求
      if (params.useMemory !== this.lastQueryParams.useMemory) {
        this.memoryData = this.selectedData.map(i => {
          return {
            ...i,
            $selected: false
          }
        })
      }
      this.state.selectCount = this.selectedData.length
      return this.pagination(params)
    }
    return this.getListByServer(params).then(response => {
      this.totalCount = response.total
      if (this.state.selectAll) {
        this.state.selectCount = response.total
      } else {
        this.state.selectCount = this.selectedData.length
      }
      return {
        total: response.total,
        list: this.dataTransform(response.list)
      }
    })
  }

  // 分页
  private pagination (params: RequestParams): Promise<TableList<TableDataRowState<TableRow>>> {
    const startIndex = (params.page - 1) * params.limit
    return Promise.resolve({
      total: this.memoryData.length,
      list: this.dataTransform(this.memoryData.slice(startIndex, startIndex + params.limit))
    })
  }

  // 格式化返回 $selected
  private dataTransform (list: TableRow[]): TableDataRowState<TableRow>[] {
    return list.map(item => {
      if (this.state.selectAll) {
        return {
          ...item,
          $selected: true
        }
      }
      let isSelected = false
      for (const i of this.selectedData) {
        if (this.isEqual(i, item)) {
          isSelected = true
          break
        }
      }
      return {
        ...item,
        $selected: isSelected
      }
    })
  }
}
